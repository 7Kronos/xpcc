// coding: utf-8
/* Copyright (c) 2015, Roboterclub Aachen e.V.
* All Rights Reserved.
*
* The file is part of the xpcc library and is released under the 3-clause BSD
* license. See the file `LICENSE` for the full license governing this code.
*/
// ----------------------------------------------------------------------------

#include <xpcc/debug/error_report.hpp>
#include <xpcc/architecture/driver/atomic/queue.hpp>
#include <xpcc/architecture/driver/atomic/lock.hpp>
#include <xpcc/utils.hpp>

#include <xpcc_config.hpp>

#include "can.hpp"

// ----------------------------------------------------------------------------
// CAN bit timing register (CAN_BTR)
#define CAN_BTR_SJW_POS		24
#define CAN_BTR_TS2_POS		20
#define CAN_BTR_TS1_POS		16

// ----------------------------------------------------------------------------

%% if parameters.tx_buffer > 0
static xpcc::atomic::Queue<xpcc::can::Message, {{ parameters.tx_buffer }}> txQueue;
bool transmission_in_progress = false;
%% else
uint8_t free_buffer = 15;
%% endif

%% if parameters.rx_buffer > 0
static xpcc::atomic::Queue<xpcc::can::Message, {{ parameters.rx_buffer }}> rxQueue;
%% else
uint8_t messages_waiting = 0;
%% endif

// HAL: enter standby mode => messages are not transmitted nor received
void
enter_standby_mode()
{
	// request abort
	CANGCON = (1 << ABRQ);

	// wait until receiver is not busy
	while (CANGSTA & (1 << RXBSY))
		;

	// request standby mode
	CANGCON = 0;

	// wait until the CAN Controller has entered standby mode
	while (CANGSTA & (1 << ENFG))
		;
}

/// HAL: leave standby mode => CAN Controller is connected to CAN Bus
void
leave_standby_mode()
{
	// save CANPAGE register
	uint8_t canpage = CANPAGE;

	// reenable all MObs
	for (uint8_t i = 0; i < 15; i++) {
		CANPAGE = i << 4;
		CANCDMOB = CANCDMOB;
	}

	// restore CANPAGE
	CANPAGE = canpage;

	// request normal mode
	CANGCON = (1 << ENASTB);

	// wait until the CAN Controller has left standby mode
	while ((CANGSTA & (1 << ENFG)) == 0)
		;
}

/// HAL: Disable the interrupt for a specific MOb
void
disable_mob_interrupt(uint8_t mob)
{
	if (mob < 8) {
		CANIE2 &= ~(1 << mob);
	} else {
		CANIE1 &= ~(1 << (mob - 8));
	}
}

/// HAL: Enable the interrupt for a specific MOb
void
enable_mob_interrupt(uint8_t mob)
{
	if (mob < 8) {
		CANIE2 |= (1 << mob);
	} else {
		CANIE1 |= (1 << (mob - 8));
	}
}

/// HAL: Copy data from a message in RAM to the actual registers
/// \warning this function assumes CANPAGE to be set properly before the call
void
copy_message_to_mob(const xpcc::can::Message& msg)
{
	// write DLC (Data Length Code)
	CANCDMOB = msg.length;

	if (msg.isExtended()) {
		// extended CAN ID
		CANCDMOB |= (1 << IDE);

		CANIDT4 = (uint8_t)  msg.getIdentifier() << 3;

		uint32_t temp = msg.getIdentifier() << 3;
		uint8_t *ptr = (uint8_t *) &temp;

		CANIDT3 = *(ptr + 1);
		CANIDT2 = *(ptr + 2);
		CANIDT1 = *(ptr + 3);
	}
	else {
		// standard CAN ID
		CANIDT4 = 0;
		CANIDT3 = 0;
		CANIDT2 = (uint8_t)  msg.getIdentifier() << 5;
		CANIDT1 = (uint16_t) msg.getIdentifier() >> 3;
	}

	if (msg.isRemoteTransmitRequest()) {
		CANIDT4 |= (1 << RTRTAG);
	}
	else {
		const uint8_t *p = msg.data;
		for (uint8_t ii = 0; ii < msg.length; ++ii) {
			CANMSG = *p++;
		}
	}
}

/// HAL: Copy data from CAN registers to a message in RAM.
/// \warning this function assumes CANPAGE to be set properly before the call
void
copy_mob_to_message(xpcc::can::Message& msg)
{
	// read status
	uint8_t cancdmob = CANCDMOB;

	// read length
	msg.length = cancdmob & 0x0f;

	if (cancdmob & (1 << IDE))
	{
		// extended identifier
		uint32_t tmp;
		uint8_t *ptr = (uint8_t *) &tmp;

		*ptr       = CANIDT4;
		*(ptr + 1) = CANIDT3;
		*(ptr + 2) = CANIDT2;
		*(ptr + 3) = CANIDT1;

		msg.setIdentifier(tmp >> 3);

		/* equivalent to:
		msg->id  = (uint8_t)  CANIDT4 >> 3;
		msg->id |= (uint32_t) CANIDT3 << 5;
		msg->id |= (uint32_t) CANIDT2 << 13;
		msg->id |= (uint32_t) CANIDT1 << 21;
		*/

		msg.flags.extended = true;
	}
	else
	{
		// standard identifier
		uint16_t id;

		id  = (uint8_t)  CANIDT2 >> 5;
		id |= (uint16_t) CANIDT1 << 3;

		msg.setIdentifier((uint32_t) id);
		msg.flags.extended = false;
	}

	if (CANIDT4 & (1 << RTRTAG)) {
		// Remote Transmission Request
		msg.flags.rtr = true;
	}
	else {
		msg.flags.rtr = false;

		// read data
		uint8_t *p = msg.data;
		for (uint8_t i = 0; i < msg.length; i++) {
			*p++ = CANMSG;
		}
	}
}

/// Actually copy a message to a given MOb and start transmission
bool
sendMob(const xpcc::can::Message& message, const uint8_t mob)
{
	// load corresponding MOb page ...
	CANPAGE = (mob << 4);

	// clear flags
	CANSTMOB &= 0;

	// ... and copy the data
	copy_message_to_mob(message);

	// enable interrupt
	enable_mob_interrupt(mob);

	{
		xpcc::atomic::Lock lock;
%% if parameters.tx_buffer == 0
		freeBuffer--;
%% elif parameters.force_tx_order
		transmissionInProgress = true;
%% endif
	} // Leave critical section

	// enable transmission
	CANCDMOB |= (1 << CONMOB0);

	return true;
}

// ----------------------------------------------------------------------------
void
xpcc::at90::Can::setMode(Mode mode)
{
	if (mode == Mode::ListenOnly) {
		CANGCON |= (1 << LISTEN);
	} else {
		CANGCON &= ~(1 << LISTEN);
	}
}

// ----------------------------------------------------------------------------
void
xpcc::at90::Can::setAutomaticRetransmission(bool retransmission)
{
	if (retransmission) {
		// Enable retransmission
		CANGCON &= ~(1 << TTC);
	} else {
		// Disable retransmission
		CANGCON |=  (1 << TTC);
	}
}

// ----------------------------------------------------------------------------
bool
xpcc::at90::Can::isMessageAvailable()
{
%% if parameters.rx_buffer > 0
	return not rxQueue.isEmpty();
%% else
	// Check if there are any messages pending in the receive registers
	return (messages_waiting > 0);
%% endif
	return false;
}

// ----------------------------------------------------------------------------
bool
xpcc::at90::Can::isReadyToSend()
{
%% if parameters.tx_buffer > 0
	return (not txQueue.isFull());
%% else
	// check if there is any free MOb
	return (free_buffer > 0)
%% endif
}

// ----------------------------------------------------------------------------
bool
xpcc::at90::Can::check_message()
{
%% if parameters.rx_buffer == 0
	return (messages_waiting > 0);
%% else
	return (not rxQueue.isEmpty());
%% endif
}

// ----------------------------------------------------------------------------
bool
xpcc::at90::Can::getMessage(can::Message& message)
{
%% if parameters.rx_buffer > 0
	if (rxQueue.isEmpty())
	{
		// no message in the receive buffer
		return false;
	}
	else {
		memcpy(&message, &rxQueue.get(), sizeof(message));
		rxQueue.pop();
		return true;
	}
%% else
	bool found = false;
	uint8_t mob;

	// check if there is any waiting message
	if (not check_message())
		return false;

	// find the MOb with the received message
	for (mob = 0; mob < 15; ++mob)
	{
		CANPAGE = mob << 4;

		if (CANSTMOB & (1 << RXOK))
		{
			found = true;

			// clear flags
			CANSTMOB &= 0;
			break;
		}
	}

	if (not found) {
		return false;		// should never happen
	}

	copy_mob_to_message( message );

	// mark message as processed
	{
		xpcc::atomic::Lock lock;
		--messages_waiting;
	}

	// re-enable interrupts
	enable_mob_interrupt( mob );

	// clear flags
	CANCDMOB = (1 << CONMOB1) | (CANCDMOB & (1 << IDE));

	return true;
%% endif
}

// ----------------------------------------------------------------------------
bool
xpcc::at90::Can::sendMessage(const xpcc::can::Message& message)
{
	// check if there is any free MOb to bypass the queue directly
	uint8_t mob = find_free_mob();
	if (mob >= 15) {
		// All MOb are used at the moment, try queue
%% if parameters.tx_buffer > 0
		if (not txQueue.push(message)) {
			xpcc::ErrorReport::report(xpcc::at90::CAN_TX_OVERFLOW);
			return false;
		}
		// Message successfully queued in txQueue
		return true;
%% else
		// No queue and no free MOb, message discarded
		xpcc::ErrorReport::report(xpcc::at90::CAN_TX_OVERFLOW);
		return false;
%% endif
	}
	else {
		// At least one MOb is free. Use this to send the message immediatly
		return sendMob(message, mob);
	}

}

// ----------------------------------------------------------------------------
xpcc::at90::Can::BusState
xpcc::at90::Can::getBusState()
{
	if (CANGSTA & (1 << BOFF)) {
		return BusState::Off;
	}
	else if (CANGSTA & (1 << ERRP)) {
		return BusState::ErrorPassive;
	}
	else {
		return BusState::Connected;
	}
}

// ----------------------------------------------------------------------------
uint8_t
xpcc::at90::Can::find_free_mob()
{
	%% if parameters.tx_buffer == 0
	if (free_buffer == 0) {
		return 0xff;
	}
	%% elif parameters.force_tx_order
	if (transmission_in_progress) {
		return 0xff;
	}
	%% endif

	uint8_t i;
	for (i = 0; i < 15; i++)
	{
		// load MOb page
		CANPAGE = i << 4;

		// check if MOb is in use
		if ((CANCDMOB & ((1 << CONMOB1) | (1 << CONMOB0))) == 0) {
			return i;
		}
	}

	return 0xff;
}

// ----------------------------------------------------------------------------
bool
xpcc::at90::Can::disableFilter(uint8_t number)
{
	if (number > 14)
	{
		if (number == CAN_ALL_FILTER)
		{
			// disable interrupts
			CANIE1 = 0;
			CANIE2 = 0;

			// disable all MObs
			for (uint8_t i = 0; i < 15; i++) {
				CANPAGE = (i << 4);

				// disable MOb (read-write required)
				CANCDMOB &= 0;
				CANSTMOB &= 0;
			}

			// mark all MObs as free
			%% if parameters.rx_buffer == 0
			messages_waiting = 0;
			%% endif

			%% if parameters.tx_buffer == 0
			free_buffer = 15;
			%% endif

			return true;
		}

		// it is only possible to serve a maximum of 15 filters
		return false;
	}

	// set CAN Controller to standby mode
	enter_standby_mode();

	CANPAGE = number << 4;

	// reset flags
	CANSTMOB &= 0;
	CANCDMOB = 0;

	disable_mob_interrupt(number);

	// re-enable CAN Controller
	leave_standby_mode();

	return true;
}

bool
xpcc::at90::Can::setFilter(uint8_t number, const can_filter_t &filter)
{
	if (number > 14) {
		// it is only possible to serve a maximum of 15 filters
		return false;
	}

	// set CAN Controller to standby mode
	enter_standby_mode();

	CANPAGE = number << 4;

	CANSTMOB = 0;
	CANCDMOB = 0;

	if (filter.flags.extended == 0x3)
	{
		// extended identifier
		CANIDT4 = (uint8_t)  filter.id << 3;
		CANIDT3 = 			 filter.id >> 5;
		CANIDT2 =            filter.id >> 13;
		CANIDT1 =            filter.id >> 21;

		CANIDM4 = ((uint8_t) filter.mask << 3) | (1 << IDEMSK);
		CANIDM3 = 			 filter.mask >> 5;
		CANIDM2 =            filter.mask >> 13;
		CANIDM1 =            filter.mask >> 21;

		CANCDMOB |= (1 << IDE);
	}
	else {
		CANIDT4 = 0;
		CANIDT3 = 0;
		CANIDT2 = (uint8_t)  filter.id << 5;
		CANIDT1 = (uint16_t) filter.id >> 3;

		if (filter.flags.extended) {
			CANIDM4 = (1 << IDEMSK);		// receive only standard frames
		} else {
			CANIDM4 = 0;					// receive all frames
		}

		CANIDM3 = 0;
		CANIDM2 = (uint8_t)  filter.mask << 5;
		CANIDM1 = (uint16_t) filter.mask >> 3;
	}

	if (filter.flags.rtr & 0x2) {
		CANIDM4 |= (1 << RTRMSK);

		if (filter.flags.rtr & 0x1) {
			CANIDT4 |= (1 << RTRMSK);		// only RTR-frames
		}
	}

	CANCDMOB |= (1 << CONMOB1);

	enable_mob_interrupt(number);

	// re-enable CAN Controller
	leave_standby_mode();

	return true;
}

// ----------------------------------------------------------------------------
// The CANPAGE register have to be restored after usage, otherwise it
// could cause trouble in the application programm.

ISR(CANIT_vect)
{
	uint8_t canpage;
	uint8_t mob;

	if ((CANHPMOB & 0xF0) != 0xF0)
	{
		// save MOb page register
		canpage = CANPAGE;

		// select MOb page with the highest priority
		CANPAGE = CANHPMOB & 0xF0;
		mob = (CANHPMOB >> 4);

		// a interrupt is only generated if a message was transmitted or received
		if (CANSTMOB & (1 << TXOK))
		{
			// clear MOb
			CANSTMOB &= 0;
			CANCDMOB = 0;

%% if parameters.tx_buffer > 0

			// check if there are any another messages waiting
			if (txQueue.isEmpty())
			{
				// buffer underflow => no more messages to send
				disable_mob_interrupt(mob);
				transmission_in_progress = false;
			}
			else {
				copy_message_to_mob(txQueue.get());
				txQueue.pop();

				// enable transmission
				CANCDMOB |= (1 << CONMOB0);
			}
%% else
			free_buffer++;

			// reset interrupt
			if (mob < 8)
				CANIE2 &= ~(1 << mob);
			else
				CANIE1 &= ~(1 << (mob - 8));
%% endif
		}
		else {
			// a message was received successfully
%% if parameters.rx_buffer > 0

			// read message
			xpcc::can::Message msg;
			copy_mob_to_message(msg);

			// push it to the list

			if (not rxQueue.push(msg)) {
				// buffer overflow => reject message
				xpcc::ErrorReport::report(xpcc::at90::CAN{{ id }}_QUEUE_OVERFLOW);
			}

			// clear flags
			CANSTMOB &= 0;
			CANCDMOB = (1 << CONMOB1) | (CANCDMOB & (1 << IDE));
%% else
			messages_waiting++;

			// reset interrupt
			if (mob < 8)
				CANIE2 &= ~(1 << mob);
			else
				CANIE1 &= ~(1 << (mob - 8));
%% endif
		}

		// restore MOb page register
		CANPAGE = canpage;
	}
	else
	{
		// no MOb matches with the interrupt => general interrupt
		CANGIT |= 0;
	}
}

// ----------------------------------------------------------------------------
// Overflow of CAN timer
ISR(OVRIT_vect)
{

}
