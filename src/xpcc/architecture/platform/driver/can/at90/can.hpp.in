// coding: utf-8
/* Copyright (c) 2015, Roboterclub Aachen e.V.
* All Rights Reserved.
*
* The file is part of the xpcc library and is released under the 3-clause BSD
* license. See the file `LICENSE` for the full license governing this code.
*/
// ----------------------------------------------------------------------------

#ifndef XPCC_AT90_CAN_HPP
#define XPCC_AT90_CAN_HPP

#include <xpcc/architecture/interface/can.hpp>
#include <xpcc/architecture/interface/can_message.hpp>
#include "../../../device.hpp"
#include "../../../type_ids.hpp"

#include "../../clock/generic/common_clock.hpp"
#include "error_code.hpp"

using namespace xpcc::clock; // for MHzxx

#define SUPPORT_EXTENDED_CANID

/**
 * @ingroup 	{{target.string}}
 * @defgroup	{{target.string}}_can CAN
 */

namespace xpcc
{

namespace at90
{

/**
 * CAN
 *
 * The peripheral interfaces the CAN network. It supports the CAN protocols
 * version 2.0A and B. There are 15 Message Objects (MOb) available for
 * reception and transmission
 *
 * ## Filter
 *
 *
 * ## Configuration
 * You can set the buffer size using the `tx_buffer` and `rx_buffer` parameters.
 *
 * @author		Fabian Greif <fabian.greif@rwth-aachen.de>
 * @author		<stronglytyp3d@gmail.com>
 * @ingroup		{{target.string}}_can
 */
class Can : public ::xpcc::Can
{
public:
	enum class
	Mode : uint8_t
	{
		Normal,
		ListenOnly,
	};

public:
	/// TypeId used to connect GPIO pins to this peripheral's rx.
	static const TypeId::CanRx Rx;
	/// TypeId used to connect GPIO pins to this peripheral's tx.
	static const TypeId::CanTx Tx;

private:
	/// get next free MOb
	static uint8_t
	find_free_mob(void);

	static bool
	check_message();

	static constexpr uint8_t
	bitrate_config[8][3] = {
		// 10 kbps
		{	0x7E,
			0x6E,
			0x7F
		},
		// 20 kbps
		{	0x62,
			0x0C,
			0x37
		},
		// 50 kbps
		{	0x26,
			0x0C,
			0x37
		},
		// 100 kbps
		{	0x12,
			0x0C,
			0x37
		},
		// 125 kbps
		{	0x0E,
			0x0C,
			0x37
		},
		// 250 kbps
		{	0x06,
			0x0C,
			0x37
		},
		// 500 kbps
		{	0x02,
			0x0C,
			0x37
		},
		// 1 Mbps
		{	0x00,
			0x0C,
			0x36
		}
	};

	static constexpr uint8_t CAN_ALL_FILTER = 0xff;

	/// Get the index for the table lookup at compile time.
	static constexpr uint8_t bitrate_index(Bitrate bitrate) {
		return
			       ( bitrate == Bitrate::kBps10)  ? 0 :
			      (( bitrate == Bitrate::kBps20)  ? 1 :
			     ((( bitrate == Bitrate::kBps50)  ? 2 :
	   		    (((( bitrate == Bitrate::kBps100) ? 3 :
			   ((((( bitrate == Bitrate::kBps125) ? 4 :
			  (((((( bitrate == Bitrate::kBps250) ? 5 :
			 ((((((( bitrate == Bitrate::kBps500) ? 6 :
			(((((((( bitrate == Bitrate::MBps1)   ? 7 :
				     0xff ))))))))))))))))))))))))))));
	}

	/// Get the value for CANBT1 at compile time.
	static constexpr uint8_t bt1(Bitrate bitrate) {
		return bitrate_config[bitrate_index(bitrate)][0];
	}

	/// Get the value for CANBT2 at compile time.
	static constexpr uint8_t bt2(Bitrate bitrate) {
		return bitrate_config[bitrate_index(bitrate)][1];
	}

	/// Get the value for CANBT3 at compile time.
	static constexpr uint8_t bt3(Bitrate bitrate) {
		return bitrate_config[bitrate_index(bitrate)][2];
	}

public:
	/**
	 * Enables the clock for the CAN controller and resets all settings
	 *
	 * \param bitrate
	 * 			CAN bitrate (defined in driver/connectivity/can/message.hpp)
	 * \param interruptPriority
	 * 			Interrupt vector priority (0=highest to 15=lowest)
	 *
	 * \warning	Has to called after connect(), but before any
	 * 			other function from this class!
	 */
	template< class SystemClock, Bitrate bitrate = Bitrate::kBps125 >
	static void
	initialize(Mode startupMode = Mode::Normal)
	{
		static_assert(SystemClock::Can == MHz16,
			"Unsupported CPU frequency for CAN peripheral. "
			"Only 16 MHz is supported at the moment");

		static_assert(bitrate_index(bitrate) <= 7,
			"Unsupported bitrate. 10, 20, 50, 100, 125, 250, 500kbps and 1Mbps" );

		// switch CAN controller to reset mode
		CANGCON |= (1 << SWRES);

		// set CAN Bit Timing
		// (see datasheet page 260)
		CANBT1 = bt1(bitrate);
		CANBT2 = bt2(bitrate);
		CANBT3 = bt3(bitrate);

		// activate CAN transmit- and receive-interrupt
		CANGIT = 0;
		CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);

		// set timer prescaler to 199 which results in a timer
		// frequency of 10 kHz (at 16 MHz)
		CANTCON = 199;

		// disable all filters
		disableFilter( 0xff );

		// activate CAN controller
		if (startupMode == Mode::ListenOnly) {
			CANGCON = (1 << ENASTB) | (1 << LISTEN);
		} else {
			CANGCON = (1 << ENASTB);
		}

		return;
	}

	/**
	 * The the operating mode.
	 *
	 * Default after initialization is the normal mode.
	 */
	static void
	setMode(Mode mode);

	static void
	setAutomaticRetransmission(bool retransmission);

public:
	// Can Interface Methods
	static bool
	isMessageAvailable();

	static bool
	getMessage(can::Message& message);

	static bool
	isReadyToSend();

	static bool
	sendMessage(const can::Message& message);

public:
	// Extended Functionality
	/**
	 * Get Receive Error Counter.
	 *
	 * In case of an error during reception, this counter is
	 * incremented by 1 or by 8 depending on the error condition as
	 * defined by the CAN standard. After every successful reception
	 * the counter is decremented by 1 or reset to 120 if its value
	 * was higher than 128. When the counter value exceeds 127, the
	 * CAN controller enters the error passive state.
	 */
	static inline uint8_t
	getReceiveErrorCounter()
	{
		return CANREC;
	}

	/**
	 * Get Transmit Error Counter.
	 *
	 */
	static inline uint8_t
	getTransmitErrorCounter()
	{
		return CANTEC;
	}

	static BusState
	getBusState();

public:
	// Acceptance filters

	// ----------------------------------------------------------------------------
	// disable mob
	static bool
	disableFilter(uint8_t number);

	typedef struct
	{
		uint32_t id;				//!< ID der Nachricht (11 oder 29 Bit)
		uint32_t mask;				//!< Maske
		struct {
			uint8_t rtr : 2;		//!< Remote Request Frame
			uint8_t extended : 2;	//!< extended ID
		} flags;
	} can_filter_t;

	static bool
	setFilter(uint8_t number, const can_filter_t &filter);

};

}	// namespace at90

}	// namespace xpcc

#endif	//  XPCC_AT90_CAN_HPP

