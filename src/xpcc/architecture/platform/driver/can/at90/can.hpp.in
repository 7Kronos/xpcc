// coding: utf-8
/* Copyright (c) 2015, Roboterclub Aachen e.V.
* All Rights Reserved.
*
* The file is part of the xpcc library and is released under the 3-clause BSD
* license. See the file `LICENSE` for the full license governing this code.
*/
// ----------------------------------------------------------------------------

#ifndef XPCC_AT90_CAN_HPP
#define XPCC_AT90_CAN_HPP

#include <xpcc/architecture/interface/can.hpp>
#include <xpcc/architecture/interface/can_message.hpp>
#include "../../../device.hpp"
#include "../../../type_ids.hpp"

#include "../../clock/generic/common_clock.hpp"

using namespace xpcc::clock; // for MHzxx

#define SUPPORT_EXTENDED_CANID

/**
 * @ingroup 	{{target.string}}
 * @defgroup	{{target.string}}_can CAN
 */

namespace xpcc
{

namespace at90
{

/**
 * @brief		Basic Extended CAN{{ id }}
 *
 * The Basic Extended CAN peripheral, named bxCAN, interfaces the CAN
 * network. It supports the CAN protocols version 2.0A and B. It has
 * been designed to manage a high number of incoming messages
 * efficiently with a minimum CPU load.
 *
 * ## Filter
 *
 * For connectivity line devices there are 28 filter banks,
 * i=0 .. 27, in other devices there are 14 filter banks i = 0 ..13.
 *
 * The 28 filter banks for the connectivity line devices are
 * shared between CAN1 and CAN2.
 *
 * ## Configuration
 * You can set the buffer size using the `tx_buffer` and `rx_buffer` parameters.
 *
 * @author		Fabian Greif <fabian.greif@rwth-aachen.de>
 * @ingroup		{{target.string}}_can
 */
class Can : public ::xpcc::Can
{
public:
	enum class
	Mode : uint32_t
	{
		Normal		= 0,
//		ListenOnly	= CAN_BTR_SILM,
//		LoopBack	= CAN_BTR_LBKM,
//		ListenOnlyLoopBack	= CAN_BTR_SILM | CAN_BTR_LBKM,
	};

public:
	/// TypeId used to connect GPIO pins to this peripheral's rx.
//	static const TypeId::CanNRx Rx;
	/// TypeId used to connect GPIO pins to this peripheral's tx.
//	static const TypeId::CanNTx Tx;

private:
public:
	/// Private Initializer with computed prescaler and timing constants
	static void
	initializeWithPrescaler(uint16_t prescaler, uint8_t bs1, uint8_t bs2,
	uint32_t interruptPriority, Mode startupMode, bool overwriteOnOverrun);


	/// get next free MOb
	static uint8_t
	find_free_mob(void);

	/// disable interrupt of corresponding MOb
	static void
	disable_mob_interrupt(uint8_t mob);

	/// enable interrupt of corresponding MOb
	static void
	enable_mob_interrupt(uint8_t mob);

	/// enter standby mode => messages are not transmitted nor received
	static void
	enter_standby_mode();

	/// leave standby mode => CAN Controller is connected to CAN Bus
	static void
	leave_standby_mode();


	/// Copy data form a message in RAM to the actual registers
	/// \warning this function assumes CANPAGE to be set properly before the call
	static void
	copy_message_to_mob(const xpcc::can::Message& msg);

	static void
	copy_mob_to_message(xpcc::can::Message& msg);

	static bool
	check_message();

	static uint8_t
	bitrate_config[8][3];

	static constexpr uint8_t CAN_ALL_FILTER = 0xff;

public:
	/**
	 * Enables the clock for the CAN controller and resets all settings
	 *
	 * \param bitrate
	 * 			CAN bitrate (defined in driver/connectivity/can/message.hpp)
	 * \param interruptPriority
	 * 			Interrupt vector priority (0=highest to 15=lowest)
	 * \param overwriteOnOverrun
	 * 			Once a receive FIFO is full the next incoming message
	 * 			will overwrite the previous one if \c true otherwise
	 * 			the incoming message will be discarded
	 *
	 * \warning	Has to called after connect(), but before any
	 * 			other function from this class!
	 */
	template< class clockSource, uint32_t bitrate = Bitrate::kBps125,
			uint16_t tolerance = Tolerance::OnePercent >
	static void
	initialize(	Mode startupMode = Mode::Normal,
				bool overwriteOnOverrun = true)
	{
		// switch CAN controller to reset mode
		CANGCON |= (1 << SWRES);

		// set CAN Bit Timing
		// (see datasheet page 260)
		uint8_t bitrate = 4; // 125 kBit
		CANBT1 = bitrate_config[bitrate][0];
		CANBT2 = bitrate_config[bitrate][1];
		CANBT3 = bitrate_config[bitrate][2];

		// activate CAN transmit- and receive-interrupt
		CANGIT = 0;
		CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);

		// set timer prescaler to 199 which results in a timer
		// frequency of 10 kHz (at 16 MHz)
		CANTCON = 199;

		// disable all filters
		disable_filter( 0xff );

		// activate CAN controller
		CANGCON = (1 << ENASTB);

		return;
	}

	// ----------------------------------------------------------------------------
	// disable mob
	static bool
	disable_filter(uint8_t number);


	typedef struct
	{
		#if	defined(SUPPORT_EXTENDED_CANID)
			uint32_t id;				//!< ID der Nachricht (11 oder 29 Bit)
			uint32_t mask;				//!< Maske
			struct {
				uint8_t rtr : 2;		//!< Remote Request Frame
				uint8_t extended : 2;	//!< extended ID
			} flags;
		#else
			uint16_t id;				//!< ID der Nachricht 11 Bits
			uint16_t mask;				//!< Maske
			struct {
				uint8_t rtr : 2;		//!< Remote Request Frame
			} flags;
		#endif
	} can_filter_t;

	static bool
	set_filter(uint8_t number, const can_filter_t &filter);


	/**
	 * The the operating mode.
	 *
	 * Default after initialization is the normal mode.
	 */
	static void
	setMode(Mode mode);

	static void
	setAutomaticRetransmission(bool retransmission);

public:
	// Can Interface Methods
	static bool
	isMessageAvailable();

	static bool
	getMessage(can::Message& message);

	static bool
	isReadyToSend();

	static bool
	sendMessage(const can::Message& message);

public:
	// Extended Functionality
	/**
	 * Get Receive Error Counter.
	 *
	 * In case of an error during reception, this counter is
	 * incremented by 1 or by 8 depending on the error condition as
	 * defined by the CAN standard. After every successful reception
	 * the counter is decremented by 1 or reset to 120 if its value
	 * was higher than 128. When the counter value exceeds 127, the
	 * CAN controller enters the error passive state.
	 */
	static inline uint8_t
	getReceiveErrorCounter()
	{
//		return ({{ reg }}->ESR & CAN_ESR_REC) >> 24;
		return 0;
	}

	/**
	 * Get Transmit Error Counter.
	 *
	 */
	static inline uint8_t
	getTransmitErrorCounter()
	{
//		return ({{ reg }}->ESR & CAN_ESR_TEC) >> 16;
		return 0;
	}

	static BusState
	getBusState();

	/**
	 * Enable the error and status change interrupt.
	 *
	 * Can be generated by the following events:
	 * - Error condition, for more details on error conditions please
	 *   refer to the CAN Error Status register (CAN_ESR).
	 * - Wakeup condition, SOF monitored on the CAN Rx signal.
	 * - Entry into Sleep mode
	 *
	 * You need to create you own interrupt handler for this interrupt.
	 * The interrupt handler has a fixed name:
	 * \code
	 * extern "C" void
	 * CAN{{ id }}_SCE_IRQHandler()
	 * {
	 *     ...
	 *
	 *     // e.g. Acknowledge interrupt
	 *     CAN{{ id }}->MSR = CAN_MSR_ERRI;
	 * }
	 * \endcode
	 *
	 * \param interruptEnable
	 * 			Upper 24-bit of the CAN_IER register. E.g.:
	 * 			 - CAN_IER_BOFIE
	 * 			 - CAN_IER_EPVIE
	 * 			 - ...
	 * 			See Reference Manual >> bxCAN >> CAN_IER Register
	 * \param interruptPriority
	 * 			Interrupt vector priority (0=highest to 15=lowest)
	 */
	static void
	enableStatusChangeInterrupt(uint32_t interruptEnable,
			uint32_t interruptPriority);
};

}	// namespace at90

}	// namespace xpcc

#endif	//  XPCC_AT90_CAN_HPP

